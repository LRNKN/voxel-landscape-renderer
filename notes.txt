NOTES DURING MY STUDY OF WEBGL2
===============================

Taken from https://webgl2fundamentals.org/

WebGL is just a rasterization engine: it takes primitives (e.g. triangles) and rasterizes them into pixels. It does nothing else.

A WebGL program is the combination of two things:
	A vertex shader, that computes rasterized vertex positions from primitives
		The vertex shader is a function that is called once per vertex
	A fragment shader, that computes a color for each pixel of a primitive
		The fragment shader is a function that is called once per rasterized pixel of a primitive

We can send the GPU data in any of the following ways:
	Buffers: arrays of binary data accessed in sequence
	Attributes: GPU input variables whose values are read in from buffers
	Vertex Array Object: the combined state of attributes and the buffers they read from
	Uniforms: global variables
	Textures: arrays of data that can be randomly accessed
	Varying: variables passed from the vertex shader to the fragment shader
		WebGL interpolates between varyings, so triangles can have a gradient

The process looks like this for triangles
	1.	Hook up our buffers
	2.	Call drawArrays with gl.TRIANGLE
	3.	For every batch of input, the vertex shader calculates a vertex position
	4.	For every three vertex positions, a triangle is rasterized
	5.	For every pixel in that rasterized triangle, the fragment shader calculates a color
	6.	The color is drawn to the screen

The vertex shader shader can pass data to the fragment shader
If we want to pass data to the fragment shader, we can pass it to the vertex shader and it can pass it on through to the vertex shader

Suppose our vertex shader has an input variable:
	in vec4 a_color;
We can get a reference to that variable:
	let colorLocation = gl.getAttribLocation(program, "a_color");
And then create a buffer of data:
	let buffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([ ... ]), gl.STATIC_DRAW);
Turn on sending data to the attribute from a buffer:
	gl.enableVertexAttribArray(colorLocation);
Tell WebGL how to get data out of the buffer, and into which attribute:
	gl.vertexAttribPointer(colorLocation, 4, gl.FLOAT, false, 0, 0);
And now that it's linked we can use gl.ARRAY_BUFFER for something else

Suppose our vertex shader uses a uniform:
	uniform vec4 u_offset;
We'd look up the location of the uniform:
	let offsetLoc = gl.getUniformLocation(someProgram, "u_offset");
And then set the value of the uniform:
	gl.uniform4fv(offsetLoc, [ 1, 0, 0, 0 ]);
There's a function for each type of uniform.

